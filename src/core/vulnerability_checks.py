"""
Vulnerability checks for various types of web vulnerabilities.
"""

import logging
import re
import urllib.parse
import requests
from typing import Dict, List, Any, Optional
from bs4 import BeautifulSoup

logger = logging.getLogger(__name__)

# SQL Injection payloads
SQL_INJECTION_PAYLOADS = [
    "' OR '1'='1",
    "1' OR '1'='1",
    "' OR 1=1--",
    "\" OR 1=1--",
    "' OR '1'='1' --",
    "admin'--",
    "1' ORDER BY 1--",
    "1' UNION SELECT 1,2,3--",
]

# XSS payloads
XSS_PAYLOADS = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg onload=alert('XSS')>",
    "\"><script>alert('XSS')</script>",
    "javascript:alert('XSS')",
    "<body onload=alert('XSS')>",
]

# CSRF detection patterns
CSRF_PATTERNS = [
    r"csrf_token",
    r"_token",
    r"authenticity_token",
    r"xsrf",
    r"nonce",
]


def run_sql_injection_check(page: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Check for SQL injection vulnerabilities.
    
    Args:
        page: Page information dictionary
        
    Returns:
        List of detected vulnerabilities
    """
    vulnerabilities = []
    
    # Check forms for SQL injection
    for form in page.get("forms", []):
        form_action = form.get("action", "")
        form_method = form.get("method", "GET")
        
        # Build target URL for the form
        if not form_action:
            form_action = page["url"]
        elif not form_action.startswith(("http://", "https://")):
            form_action = urllib.parse.urljoin(page["url"], form_action)
            
        # Check each input in the form
        for input_field in form.get("inputs", []):
            input_name = input_field.get("name", "")
            if not input_name:
                continue
                
            # Skip non-text inputs
            input_type = input_field.get("type", "text").lower()
            if input_type in ["submit", "button", "image", "file", "checkbox", "radio"]:
                continue
                
            # Try SQL injection payloads
            for payload in SQL_INJECTION_PAYLOADS:
                try:
                    # Prepare data for request
                    data = {}
                    for field in form.get("inputs", []):
                        field_name = field.get("name", "")
                        if not field_name:
                            continue
                        
                        if field_name == input_name:
                            data[field_name] = payload
                        else:
                            data[field_name] = field.get("value", "")
                    
                    # Send request
                    if form_method.upper() == "GET":
                        response = requests.get(form_action, params=data, timeout=10)
                    else:
                        response = requests.post(form_action, data=data, timeout=10)
                    
                    # Check for SQL error patterns in response
                    error_patterns = [
                        "SQL syntax",
                        "mysql_fetch_array",
                        "ORA-",
                        "PostgreSQL",
                        "SQLite",
                        "mysql_",
                        "syntax error",
                        "Division by zero",
                        "Microsoft OLE DB Provider for SQL Server",
                    ]
                    
                    content = response.text.lower()
                    for pattern in error_patterns:
                        if pattern.lower() in content:
                            vulnerabilities.append({
                                "type": "sql_injection",
                                "url": form_action,
                                "method": form_method,
                                "param": input_name,
                                "payload": payload,
                                "evidence": pattern,
                                "severity": "high"
                            })
                            break
                            
                except Exception as e:
                    logger.warning(f"Error testing SQL injection on {form_action}: {str(e)}")
    
    return vulnerabilities
    

def run_xss_check(page: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Check for Cross-Site Scripting (XSS) vulnerabilities.
    
    Args:
        page: Page information dictionary
        
    Returns:
        List of detected vulnerabilities
    """
    vulnerabilities = []
    
    # Check forms for XSS
    for form in page.get("forms", []):
        form_action = form.get("action", "")
        form_method = form.get("method", "GET")
        
        # Build target URL for the form
        if not form_action:
            form_action = page["url"]
        elif not form_action.startswith(("http://", "https://")):
            form_action = urllib.parse.urljoin(page["url"], form_action)
            
        # Check each input in the form
        for input_field in form.get("inputs", []):
            input_name = input_field.get("name", "")
            if not input_name:
                continue
                
            # Skip non-text inputs
            input_type = input_field.get("type", "text").lower()
            if input_type in ["submit", "button", "image", "file", "checkbox", "radio"]:
                continue
                
            # Try XSS payloads
            for payload in XSS_PAYLOADS:
                try:
                    # Prepare data for request
                    data = {}
                    for field in form.get("inputs", []):
                        field_name = field.get("name", "")
                        if not field_name:
                            continue
                        
                        if field_name == input_name:
                            data[field_name] = payload
                        else:
                            data[field_name] = field.get("value", "")
                    
                    # Send request
                    if form_method.upper() == "GET":
                        response = requests.get(form_action, params=data, timeout=10)
                    else:
                        response = requests.post(form_action, data=data, timeout=10)
                    
                    # Check if payload appears in response
                    if payload in response.text:
                        vulnerabilities.append({
                            "type": "xss",
                            "url": form_action,
                            "method": form_method,
                            "param": input_name,
                            "payload": payload,
                            "evidence": payload,
                            "severity": "high"
                        })
                        break
                            
                except Exception as e:
                    logger.warning(f"Error testing XSS on {form_action}: {str(e)}")
    
    # Also check URL parameters for reflected XSS
    url_params = urllib.parse.parse_qs(urllib.parse.urlparse(page["url"]).query)
    for param_name, param_values in url_params.items():
        for payload in XSS_PAYLOADS:
            try:
                # Build URL with payload
                parsed_url = urllib.parse.urlparse(page["url"])
                query_params = urllib.parse.parse_qs(parsed_url.query)
                query_params[param_name] = [payload]
                
                # Rebuild query string
                new_query = urllib.parse.urlencode(query_params, doseq=True)
                new_url = urllib.parse.urlunparse((
                    parsed_url.scheme,
                    parsed_url.netloc,
                    parsed_url.path,
                    parsed_url.params,
                    new_query,
                    parsed_url.fragment
                ))
                
                # Send request
                response = requests.get(new_url, timeout=10)
                
                # Check if payload appears in response
                if payload in response.text:
                    vulnerabilities.append({
                        "type": "xss",
                        "url": page["url"],
                        "method": "GET",
                        "param": param_name,
                        "payload": payload,
                        "evidence": payload,
                        "severity": "high"
                    })
                    break
                    
            except Exception as e:
                logger.warning(f"Error testing XSS on URL param {param_name}: {str(e)}")
    
    return vulnerabilities


def run_csrf_check(page: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Check for Cross-Site Request Forgery (CSRF) vulnerabilities.
    
    Args:
        page: Page information dictionary
        
    Returns:
        List of detected vulnerabilities
    """
    vulnerabilities = []
    
    # Check forms for CSRF tokens
    for form in page.get("forms", []):
        # Only check non-GET forms (GET is not susceptible to CSRF)
        form_method = form.get("method", "GET").upper()
        if form_method != "POST":
            continue
            
        # Check if form has CSRF token
        has_csrf_token = False
        form_inputs = form.get("inputs", [])
        
        for input_field in form_inputs:
            input_name = input_field.get("name", "").lower()
            if not input_name:
                continue
                
            # Check if input name matches CSRF token pattern
            for pattern in CSRF_PATTERNS:
                if re.search(pattern, input_name, re.IGNORECASE):
                    has_csrf_token = True
                    break
                    
            if has_csrf_token:
                break
                
        # If no CSRF token found, report vulnerability
        if not has_csrf_token:
            form_action = form.get("action", "")
            if not form_action:
                form_action = page["url"]
            elif not form_action.startswith(("http://", "https://")):
                form_action = urllib.parse.urljoin(page["url"], form_action)
                
            vulnerabilities.append({
                "type": "csrf",
                "url": form_action,
                "method": form_method,
                "form_id": form.get("id", ""),
                "evidence": "Missing CSRF token in form",
                "severity": "medium"
            })
    
    return vulnerabilities


def run_idor_check(page: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Check for Insecure Direct Object References (IDOR) vulnerabilities.
    
    Args:
        page: Page information dictionary
        
    Returns:
        List of detected vulnerabilities
    """
    vulnerabilities = []
    
    # Check for potential IDOR patterns in URLs
    url = page["url"]
    parsed_url = urllib.parse.urlparse(url)
    
    # Check path segments for numeric IDs
    path_segments = parsed_url.path.split("/")
    
    for i, segment in enumerate(path_segments):
        # Check if segment looks like an ID (numeric or GUID)
        if segment.isdigit() or (len(segment) == 36 and "-" in segment):
            # Check if this segment can be accessed with a different ID
            original_id = segment
            
            # For numeric IDs, try a different number
            if segment.isdigit():
                # Try a different ID that's +/- 1 from the original
                test_id = str(int(segment) + 1)
            else:
                # For GUIDs, skip (too many combinations)
                continue
                
            # Replace the ID in the path
            test_path_segments = path_segments.copy()
            test_path_segments[i] = test_id
            test_path = "/".join(test_path_segments)
            
            # Build the test URL
            test_url = urllib.parse.urlunparse((
                parsed_url.scheme,
                parsed_url.netloc,
                test_path,
                parsed_url.params,
                parsed_url.query,
                parsed_url.fragment
            ))
            
            try:
                # Send request
                response = requests.get(test_url, timeout=10)
                
                # If successful response and similar content, potential IDOR
                if response.status_code == 200:
                    # Basic content similarity check (could be improved)
                    # Compare content length - if similar, might be IDOR
                    original_content_length = page.get("size", 0)
                    test_content_length = len(response.content)
                    
                    # If length is similar (within 10%), consider as potential IDOR
                    if abs(original_content_length - test_content_length) / original_content_length < 0.1:
                        vulnerabilities.append({
                            "type": "idor",
                            "url": url,
                            "param_location": "path",
                            "param_name": f"segment_{i}",
                            "original_value": original_id,
                            "test_value": test_id,
                            "evidence": f"Similar content found at {test_url}",
                            "severity": "high"
                        })
                        
            except Exception as e:
                logger.warning(f"Error testing IDOR on {test_url}: {str(e)}")
    
    # Also check query parameters for potential IDs
    query_params = urllib.parse.parse_qs(parsed_url.query)
    
    for param_name, param_values in query_params.items():
        if not param_values:
            continue
            
        original_value = param_values[0]
        
        # Check if parameter value looks like an ID
        if original_value.isdigit() or (len(original_value) == 36 and "-" in original_value):
            # For numeric IDs, try a different number
            if original_value.isdigit():
                test_value = str(int(original_value) + 1)
            else:
                # For GUIDs, skip
                continue
                
            # Build test URL with different ID
            query_params_copy = query_params.copy()
            query_params_copy[param_name] = [test_value]
            test_query = urllib.parse.urlencode(query_params_copy, doseq=True)
            
            test_url = urllib.parse.urlunparse((
                parsed_url.scheme,
                parsed_url.netloc,
                parsed_url.path,
                parsed_url.params,
                test_query,
                parsed_url.fragment
            ))
            
            try:
                # Send request
                response = requests.get(test_url, timeout=10)
                
                # If successful response and similar content, potential IDOR
                if response.status_code == 200:
                    # Basic content similarity check
                    original_content_length = page.get("size", 0)
                    test_content_length = len(response.content)
                    
                    if abs(original_content_length - test_content_length) / original_content_length < 0.1:
                        vulnerabilities.append({
                            "type": "idor",
                            "url": url,
                            "param_location": "query",
                            "param_name": param_name,
                            "original_value": original_value,
                            "test_value": test_value,
                            "evidence": f"Similar content found at {test_url}",
                            "severity": "high"
                        })
                        
            except Exception as e:
                logger.warning(f"Error testing IDOR on {test_url}: {str(e)}")
    
    return vulnerabilities 